WEBVTT

1
00:00:00.000 --> 00:00:01.965
Khi triển khai mạng nơron sâu

2
00:00:01.965 --> 00:00:04.200
một trong những công cụ gỡ lỗi
mà tôi thường

3
00:00:04.200 --> 00:00:06.555
sử dụng để kiểm tra độ chính xác của mã của tôi

4
00:00:06.555 --> 00:00:08.760
là kéo một mảnh giấy và chỉ

5
00:00:08.760 --> 00:00:11.475
làm việc thông qua các chiều
trong ma trận mà tôi đang làm việc.

6
00:00:11.475 --> 00:00:14.190
Hãy để tôi chỉ cho bạn cách thực hiện điều đó
vì tôi hy vọng điều này

7
00:00:14.190 --> 00:00:15.810
sẽ giúp bạn dễ dàng hơn

8
00:00:15.810 --> 00:00:17.490
để triển khai mạng sâu

9
00:00:17.490 --> 00:00:20.300
Vậy L bằng 5.

10
00:00:20.300 --> 00:00:21.485
Tôi đã đếm chúng một cách nhanh chóng.

11
00:00:21.485 --> 00:00:22.820
Không tính lớp đầu vào,

12
00:00:22.820 --> 00:00:25.130
có 5 lớp ở đây,

13
00:00:25.130 --> 00:00:27.590
4 lớp ẩn và 1 lớp đầu ra.

14
00:00:27.590 --> 00:00:29.840
Nếu bạn triển khai lan truyền xuôi,

15
00:00:29.840 --> 00:00:34.845
bước đầu tiên sẽ là z[1] bằng

16
00:00:34.845 --> 00:00:41.655
w1 nhân với đặc trưng đầu vào x cộng với b1.

17
00:00:41.655 --> 00:00:45.230
Hãy bỏ qua phần tử độ chệch b

18
00:00:45.230 --> 00:00:48.425
và tập trung vào các tham số w.
Bây giờ,

19
00:00:48.425 --> 00:00:52.725
lớp ẩn đầu tiên này có ba đơn vị ẩn,

20
00:00:52.725 --> 00:00:56.000
đây là lớp 0,

21
00:00:56.000 --> 00:00:58.015
lớp 1, lớp 2, lớp 3,

22
00:00:58.015 --> 00:00:59.685
lớp 4 và lớp 5.

23
00:00:59.685 --> 00:01:02.960
Bằng cách sử dụng ký hiệu mà chúng ta có từ video trước,

24
00:01:02.960 --> 00:01:04.610
chúng ta có n[1], là

25
00:01:04.610 --> 00:01:06.890
số đơn vị ẩn trong lớp 1,

26
00:01:06.890 --> 00:01:08.705
bằng 3.

27
00:01:08.705 --> 00:01:13.485
Và ở đây chúng ta sẽ có n[2] bằng 5,

28
00:01:13.485 --> 00:01:16.620
n[3] bằng 4,

29
00:01:16.620 --> 00:01:19.440
n[4] bằng 2

30
00:01:19.440 --> 00:01:23.070
và n[5] bằng 1.

31
00:01:23.070 --> 00:01:24.730
Và cho đến giờ chúng ta mới chỉ thấy

32
00:01:24.730 --> 00:01:27.010
các mạng nơ-ron với một đơn vị đầu ra duy nhất,

33
00:01:27.010 --> 00:01:29.380
nhưng trong chúng ta sẽ nói về

34
00:01:29.380 --> 00:01:32.425
nơ-ron với nhiều đơn vị đầu ra.

35
00:01:32.425 --> 00:01:35.665
Cuối cùng, với lớp đầu vào,

36
00:01:35.665 --> 00:01:40.485
ta cũng có n[0] = nx = 2.

37
00:01:40.485 --> 00:01:45.775
Bây giờ, hãy nghĩ về kích thước của z, w và x.

38
00:01:45.775 --> 00:01:48.205
z là vectơ kích hoạt cho

39
00:01:48.205 --> 00:01:51.090
lớp ẩn đầu tiên này

40
00:01:51.090 --> 00:01:56.080
vậy z sẽ là (3,1),

41
00:01:56.080 --> 00:01:59.060
nó là một vectơ 3 chiều.

42
00:01:59.060 --> 00:02:06.255
Và tôi sẽ viết nó thành ma trận (n[1],1),

43
00:02:06.255 --> 00:02:08.045
và trong trường hợp này là (3,1).

44
00:02:08.045 --> 00:02:10.460
Thế còn về các đặc trưng đầuvào x?

45
00:02:10.460 --> 00:02:12.215
x có hai đặc trưng đầu vào.

46
00:02:12.215 --> 00:02:14.135
Trong ví dụ này x là

47
00:02:14.135 --> 00:02:18.835
(2,1), nhưng tổng quát hơn thì nó sẽ là (n[0],1).

48
00:02:18.835 --> 00:02:22.410
Chúng ta cần tìm ra kích thước
của ma trận w1

49
00:02:22.410 --> 00:02:26.445
để khi chúng ta nhân một vectơ (n[0],1) vectơ với ma trận đó,

50
00:02:26.445 --> 00:02:29.565
thì chúng ta sẽ có một vectơ (n[1],1).

51
00:02:29.565 --> 00:02:34.625
Và bạn có một vectơ ba chiều bằng

52
00:02:34.625 --> 00:02:38.690
bằng một cái gì đó nhân với một vectơ hai chiều.

53
00:02:38.690 --> 00:02:41.990
Và theo quy tắc nhân ma trận,

54
00:02:41.990 --> 00:02:46.800
đây phải là ma trận (3,2).

55
00:02:47.540 --> 00:02:50.880
Vì ma trận (3,2) nhân ma trận

56
00:02:50.880 --> 00:02:53.640
(2,1) hoặc nhân với vectơ (2,1),

57
00:02:53.640 --> 00:02:56.190
sẽ cho bạn vectơ (3,1).

58
00:02:56.190 --> 00:02:58.450
Và nói chung, đây sẽ là

59
00:02:58.450 --> 00:03:02.540
một ma trận (n[1],n[0]).

60
00:03:02.540 --> 00:03:06.815
Chúng ta đã tìm ra kích thước của w1

61
00:03:06.815 --> 00:03:12.465
phải là (n[1],n[0]).

62
00:03:12.465 --> 00:03:15.860
Và nói chung, kích thước của

63
00:03:15.860 --> 00:03:20.360
wL phải là (n[L],n[L - 1]).

64
00:03:20.360 --> 00:03:23.540
Ví dụ, kích thước của w2,

65
00:03:23.540 --> 00:03:29.075
phải là (5,3),

66
00:03:29.075 --> 00:03:35.080
hoặc là (n[2],n[1])

67
00:03:35.080 --> 00:03:39.100
bởi vì chúng ta sẽ tính z[2]

68
00:03:39.100 --> 00:03:46.875
bằng w[2] nhân a[1]

69
00:03:46.875 --> 00:03:50.535
và một lần nữa, hãy bỏ qua độ chênh.

70
00:03:50.535 --> 00:03:54.420
Và như vậy, đây sẽ là (3,1),

71
00:03:54.420 --> 00:03:57.780
và chúng ta cần cái này là (5,1)

72
00:03:57.780 --> 00:04:02.625
và vì vậy, cái này nên là (5,3).

73
00:04:02.625 --> 00:04:10.995
Tương tự, w[3] là kích thước
của lớp tiếp theo,

74
00:04:10.995 --> 00:04:13.605
phẩy, kích thước của lớp trước đó,

75
00:04:13.605 --> 00:04:16.620
vì vậy đây sẽ là (4,5),

76
00:04:16.620 --> 00:04:22.830
w[4]

77
00:04:22.830 --> 00:04:27.765
sẽ là (2,4) và

78
00:04:27.765 --> 00:04:33.790
w[5] sẽ là (1,2).

79
00:04:33.860 --> 00:04:37.240
Và công thức khái quát để kiểm tra là khi

80
00:04:37.240 --> 00:04:40.270
triển khai ma trận cho lớp L,

81
00:04:40.270 --> 00:04:48.030
kích thước của ma trận đó sẽ là (n[L],n[L – 1]).

82
00:04:48.030 --> 00:04:53.320
Bây giờ hãy nghĩ về chiều của vectơ b này.

83
00:04:53.320 --> 00:04:58.590
Đây là vectơ (3,1),

84
00:04:58.590 --> 00:05:01.840
vì vậy
bạn phải thêm nó vào một vectơ

85
00:05:01.840 --> 00:05:07.340
(3,1) khác để có được đầu ra là vectơ (3,1).

86
00:05:08.500 --> 00:05:11.735
Hoặc trong ví dụ này, cái này sẽ là (5,1),

87
00:05:11.735 --> 00:05:14.810
vì vậy sẽ có thêm một vectơ (5,1).

88
00:05:14.810 --> 00:05:16.700
để cho tổng

89
00:05:16.700 --> 00:05:18.860
của hai cái mà tôi để trong ô

90
00:05:18.860 --> 00:05:22.350
trở thành vectơ (5,1).

91
00:05:22.350 --> 00:05:26.380
Vậy nên quy tắc khái quát hơn là trong ví dụ bên trái,

92
00:05:26.380 --> 00:05:31.180
b1 là (n[1],1),

93
00:05:31.180 --> 00:05:33.325
đó là (3,1),

94
00:05:33.325 --> 00:05:35.214
Trong ví dụ thứ hai,

95
00:05:35.214 --> 00:05:42.400
đây là (n[2],1) và như vậy

96
00:05:42.400 --> 00:05:44.440
trường hợp tổng quát hơn

97
00:05:44.440 --> 00:05:50.605
b[L] nên là (n[L],1).

98
00:05:50.605 --> 00:05:53.620
Hy vọng rằng hai phương trình này

99
00:05:53.620 --> 00:05:56.455
sẽ giúp bạn kiểm tra lại kích thước của ma trận

100
00:05:56.455 --> 00:05:58.900
w cũng như

101
00:05:58.900 --> 00:06:01.885
các vectơ b có chiều chính xác.

102
00:06:01.885 --> 00:06:05.245
Và tất nhiên, nếu bạn đang
thực hiện lan truyền ngược,

103
00:06:05.245 --> 00:06:06.925
thì kích thước của

104
00:06:06.925 --> 00:06:10.075
dw phải
giống với kích thước của

105
00:06:10.075 --> 00:06:15.970
w. Vậy nên, dw nên có cùng kích thước với w,

106
00:06:15.970 --> 00:06:21.835
và db phải có cùng kích thước với b.

107
00:06:21.835 --> 00:06:24.519
Bây giờ, một bộ các đại lượng khác

108
00:06:24.519 --> 00:06:28.015
cần kiểm tra kích thước là z,

109
00:06:28.015 --> 00:06:31.315
x, cũng như a[L]

110
00:06:31.315 --> 00:06:33.550
mà chúng ta đã không nói quá nhiều về nó.

111
00:06:33.550 --> 00:06:39.880
Nhưng vì z[L] bằng g của a[L],

112
00:06:39.880 --> 00:06:42.655
áp dụng cho từng phần tử thì z

113
00:06:42.655 --> 00:06:44.695
và a nên có cùng kích thước

114
00:06:44.695 --> 00:06:46.540
trong các loại mạng này.

115
00:06:46.540 --> 00:06:48.865
Bây giờ hãy xem điều gì sẽ xảy ra khi bạn có

116
00:06:48.865 --> 00:06:50.770
một triển khai được vectơ hóa

117
00:06:50.770 --> 00:06:52.930
xem xét nhiều ví dụ cùng một lúc.

118
00:06:52.930 --> 00:06:55.780
Tất nhiên, ngay cả đối với triển khai vectơ hóa,

119
00:06:55.780 --> 00:06:57.940
kích thước của w,

120
00:06:57.940 --> 00:07:00.685
b, dw, và db sẽ giữ nguyên

121
00:07:00.685 --> 00:07:03.895
Nhưng kích thước của z, a,

122
00:07:03.895 --> 00:07:06.370
cũng như x sẽ thay đổi một chút

123
00:07:06.370 --> 00:07:09.355
trong triển khai vectơ hóa.

124
00:07:09.355 --> 00:07:14.140
Trước đây chúng ta đã có z[1] bằng

125
00:07:14.140 --> 00:07:21.910
w[1]x + b[1]

126
00:07:21.910 --> 00:07:26.050
trong đó đây là (n[1],1),

127
00:07:26.050 --> 00:07:29.660
đây là (n[1],n[0]),

128
00:07:29.660 --> 00:07:36.250
x là (n[0],1

129
00:07:36.250 --> 00:07:40.720
và b là (n[1],1).

130
00:07:40.720 --> 00:07:43.555
Bây giờ, trong một triển khai vectơ hóa,

131
00:07:43.555 --> 00:07:53.640
bạn sẽ có z[1] = w[1]x + b[1].

132
00:07:53.640 --> 00:07:55.950
Bây giờ ta thu được z[1] bằng cách

133
00:07:55.950 --> 00:07:59.770
lấy z[1] cho từng ví dụ riêng lẻ.

134
00:07:59.770 --> 00:08:05.170
Vì vậy, như vậy ta có z[1][1], z[1][2], đến z[1][m]

135
00:08:05.170 --> 00:08:10.660
và xếp chúng cạnh
nhau như sau và như vậy bạn có z[1].

136
00:08:10.660 --> 00:08:12.580
Như vậy kích thước của z[1]

137
00:08:12.580 --> 00:08:15.025
thay vì là (n[1],1)

138
00:08:15.025 --> 00:08:17.740
là (n[1],m)

139
00:08:17.740 --> 00:08:19.990
và m là kích thước tập huấn luyện

140
00:08:19.990 --> 00:08:23.200
Kích thước của w[1] giữ nguyên,

141
00:08:23.200 --> 00:08:26.605
vẫn là (n[1],n[0]).

142
00:08:26.605 --> 00:08:29.500
Và X, thay vì là (n[0],1)

143
00:08:29.500 --> 00:08:33.490
bây giờ tất cả các mẫu huấn luyện xếp
chồng lên nhau theo chiều ngang.

144
00:08:33.490 --> 00:08:38.500
Vậy nên bây giờ X là (n[0], m), và
bạn sẽ thấy rằng khi bạn lấy

145
00:08:38.500 --> 00:08:40.930
một ma trận (n[1],n[0]) và

146
00:08:40.930 --> 00:08:43.810
nhân nó với một ma trận (n[0],m).

147
00:08:43.810 --> 00:08:46.390
thì bạn sẽ nhận được một

148
00:08:46.390 --> 00:08:49.930
ma trận (n[1],m) như mong đợi.

149
00:08:49.930 --> 00:08:56.215
Bây giờ, một điều cuối cùng
là b1 vẫn là (n[1],1),

150
00:08:56.215 --> 00:08:58.855
nhưng khi bạn lấy cái này và thêm nó vào b,

151
00:08:58.855 --> 00:09:02.875
thì thông qua truyền phát Python sẽ được nhân đôi

152
00:09:02.875 --> 00:09:08.035
và biến thành ma
trận (n[1],m), và sau đó cộng từng phần tử.

153
00:09:08.035 --> 00:09:09.670
Ở slide trước,

154
00:09:09.670 --> 00:09:12.160
chúng ta đã nóivề kích thước của wb,

155
00:09:12.160 --> 00:09:14.770
dw và db.

156
00:09:14.770 --> 00:09:18.040
Ở đây, chúng ta có thể thấy là trong khi z[L]

157
00:09:18.040 --> 00:09:22.540
và a[L]

158
00:09:22.540 --> 00:09:27.340
có kích thước (n[L],1),

159
00:09:27.340 --> 00:09:31.480
bây giờ thay vào đó Z[L]

160
00:09:31.480 --> 00:09:36.190
và A[L]

161
00:09:36.190 --> 00:09:38.230
là (n[L],m)

162
00:09:38.230 --> 00:09:42.354
và trường hợp đặc biệt của nó là khi l=0,

163
00:09:42.354 --> 00:09:45.280
trong trường hợp đó A[0]

164
00:09:45.280 --> 00:09:47.230
bằng với đặc trưng

165
00:09:47.230 --> 00:09:49.540
đầu vào X trong
tập huấn luyện,

166
00:09:49.540 --> 00:09:54.295
sẽ bằng (n[0],m) như mong đợi.

167
00:09:54.295 --> 00:09:56.200
Tất nhiên, khi bạn

168
00:09:56.200 --> 00:10:02.020
triển khai điều này trong lan truyền ngược,

169
00:10:02.020 --> 00:10:09.205
sau này chúng ta sẽ thấy, cuối cùng
bạn sẽ tính dZ và dA.

170
00:10:09.205 --> 00:10:15.315
Tất nhiên, những thứ này sẽ có
cùng kích thước với Z và A.

171
00:10:15.315 --> 00:10:18.330
Hy vọng bài tập nhỏ trong
video này sẽ giúp

172
00:10:18.330 --> 00:10:19.890
làm rõ các kích thước của

173
00:10:19.890 --> 00:10:21.885
các ma trận khác nhau mà bạn đang làm việc

174
00:10:21.885 --> 00:10:23.850
khi triển khai lan truyền ngược

175
00:10:23.850 --> 00:10:25.005
cho một mạng nơ-ron sâu,

176
00:10:25.005 --> 00:10:27.420
miễn là bạn nghiên cứu thông qua
mã của mình và đảm bảo rằng

177
00:10:27.420 --> 00:10:30.225
tất cả các
kích thước của ma trận đều nhất quán,

178
00:10:30.225 --> 00:10:32.760
nó thường sẽ giúp bạn

179
00:10:32.760 --> 00:10:35.800
tìm ra một số cách để loại bỏ
nguyên nhân gây ra lỗi.

180
00:10:35.800 --> 00:10:38.260
Và tôi hy vọng rằng bài tập tìm ra

181
00:10:38.260 --> 00:10:40.090
kích thước của các ma trận khác nhau

182
00:10:40.090 --> 00:10:41.980
bạn đang làm việc là hữu ích.

183
00:10:41.980 --> 00:10:43.450
Khi triển khai một nơ-ron sâu,

184
00:10:43.450 --> 00:10:45.080
nếu bạn khiến

185
00:10:45.080 --> 00:10:46.790
kích thước của các ma trận khác nhau này

186
00:10:46.790 --> 00:10:48.095
và vectơ bạn đang làm việc,

187
00:10:48.095 --> 00:10:49.835
hy vọng, rằng nó sẽ giúp bạn loại bỏ

188
00:10:49.835 --> 00:10:51.575
một số loại lỗi có thể xảy ra.

189
00:10:51.575 --> 00:10:54.525
nó chắc chắn giúp tôi thực hiện đúng mã.

190
00:10:54.525 --> 00:10:58.040
Tiếp theo, bây giờ chúng ta đã thấy
một số cơ chế của

191
00:10:58.040 --> 00:11:01.280
về cách thực hiện lan truyền xuôi trong mạng nơ-ron.

192
00:11:01.280 --> 00:11:04.250
Nhưng tại sao các mạng nơ-ron sâu lại hiệu quả, và

193
00:11:04.250 --> 00:11:07.295
tại sao chúng lại làm tốt
hơn những mạng nông?

194
00:11:07.295 --> 00:11:10.770
Hãy dành vài phút trong video
tiếp theo để cùng thảo luận về điều đó.