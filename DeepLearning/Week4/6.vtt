WEBVTT

1
00:00:00.000 --> 00:00:01.740
Trong video trước, bạn đã thấy

2
00:00:01.740 --> 00:00:04.890
các khối cơ bản của việc triển khai
một mạng nơ-ron sâu,

3
00:00:04.890 --> 00:00:07.020
một bước truyền bá về phía trước cho

4
00:00:07.020 --> 00:00:09.885
mỗi lớp và một bước truyền lùi

5
00:00:09.885 --> 00:00:12.345
Hãy cùng xem cách thực hiện các bước này.

6
00:00:12.345 --> 00:00:14.085
Chúng ta sẽ bắt đầu với truyền xuôi trước.

7
00:00:14.085 --> 00:00:18.405
Nhớ lại rằng điều này sẽ
là nhập a ^ l trừ 1,

8
00:00:18.405 --> 00:00:21.900
và xuất ra a ^ l và
bộ nhớ đệm, z ^ l.

9
00:00:21.900 --> 00:00:24.615
Chúng tôi chỉ nói rằng, từ quan điểm triển khai

10
00:00:24.615 --> 00:00:28.125
có thể chúng tôi cũng sẽ lưu vào bộ nhớ cache
w ^ l và b ^ l,

11
00:00:28.125 --> 00:00:29.670
chỉ để thực hiện lệnh gọi của hàm

12
00:00:29.670 --> 00:00:31.725
dễ hơn một chút trong bài tập chương trình

13
00:00:31.725 --> 00:00:35.240
Các phương trình cho điều này
đã trông quen thuộc.

14
00:00:35.240 --> 00:00:38.900
Cách triển khai
chuyển tiếp chỉ là thế này,

15
00:00:38.900 --> 00:00:46.030
bằng w ^ l lần a ^ l
trừ 1 cộng với b ^ l,

16
00:00:46.030 --> 00:00:53.410
và sau đó a ^ l bằng
được áp dụng cho z.

17
00:00:53.410 --> 00:00:57.225
Nếu bạn muốn triển khai

18
00:00:57.225 --> 00:01:05.910
thì nó chỉ là nhân lần
a ^ l trừ 1 cộng với b,

19
00:01:05.910 --> 00:01:09.944
b là một chương trình phát sóng Python,

20
00:01:09.944 --> 00:01:12.420
và a ^ l bằng g,

21
00:01:12.420 --> 00:01:15.585
áp dụng phần tử khôn ngoan cho z.

22
00:01:15.585 --> 00:01:20.040
Bạn nhớ rằng, trên
cho bước thứ 4,

23
00:01:20.040 --> 00:01:22.470
chúng ta đã có chuỗi các
hộp truyền xuôi như này,

24
00:01:22.470 --> 00:01:25.240
vì vậy bạn khởi tạo số
bằng cách cho ăn

25
00:01:25.240 --> 00:01:29.260
trong a ^ 0, bằng x.

26
00:01:29.260 --> 00:01:31.615
Vì vậy, bạn khởi tạo điều này với,

27
00:01:31.615 --> 00:01:33.265
đầu vào
cho đầu tiên là gì?

28
00:01:33.265 --> 00:01:37.570
Nó thực sự là ^ 0,
là đầu vào

29
00:01:37.570 --> 00:01:40.390
các tính năng cho
một ví dụ đào tạo

30
00:01:40.390 --> 00:01:42.250
nếu bạn đang thực hiện từng ví dụ một,

31
00:01:42.250 --> 00:01:48.160
hoặc ^ 0 nếu bạn đang xử lý
toàn bộ tập huấn luyện.

32
00:01:48.160 --> 00:01:49.720
Đó là đầu vào cho

33
00:01:49.720 --> 00:01:51.990
chuyển tiếp đầu tiên trong chuỗi,

34
00:01:51.990 --> 00:01:54.370
và sau đó chỉ cần lặp lại
điều này cho phép bạn tính toán

35
00:01:54.370 --> 00:01:56.890
truyền thuận
từ trái sang phải.

36
00:01:56.890 --> 00:02:00.140
Tiếp theo, hãy nói về truyền ngược.

37
00:02:00.140 --> 00:02:03.575
Ở đây, mục tiêu của bạn là nhập vào da [l],

38
00:02:03.575 --> 00:02:07.800
và xuất ra da ^ l trừ
1 và dw ^ l và db ^ l.

39
00:02:07.800 --> 00:02:09.080
Hãy để tôi viết ra

40
00:02:09.080 --> 00:02:12.630
các bước bạn cần phải
tính những điều này.

41
00:02:12.960 --> 00:02:18.485
Dz ^ l bằng da ^ l
nguyên tố,

42
00:02:18.485 --> 00:02:22.070
với g của l nguyên tố z của

43
00:02:22.070 --> 00:02:27.775
l. Sau đó, để tính
các đạo hàm,

44
00:02:27.775 --> 00:02:34.515
dw ^ l bằng dz ^ l
lần a của l trừ 1.

45
00:02:34.515 --> 00:02:36.830
Tôi không rõ ràng
đặt trong bộ nhớ cache,

46
00:02:36.830 --> 00:02:39.140
nhưng hóa ra bạn
cần điều này.

47
00:02:39.140 --> 00:02:47.630
Khi đó db ^ l bằng
dz ^ l, và cuối cùng,

48
00:02:47.630 --> 00:02:52.745
da của l trừ đi 1 bằng

49
00:02:52.745 --> 00:02:59.520
w ^ l chuyển vị lần dz ^ l.

50
00:02:59.520 --> 00:03:00.770
Tôi không muốn đi qua

51
00:03:00.770 --> 00:03:02.330
chi tiết cho điều này,

52
00:03:02.330 --> 00:03:04.280
nhưng nó chỉ ra rằng nếu
bạn lấy định nghĩa này

53
00:03:04.280 --> 00:03:06.455
cho da và cắm nó vào đây,

54
00:03:06.455 --> 00:03:08.465
sau đó bạn nhận được cùng một công thức

55
00:03:08.465 --> 00:03:10.310
như chúng tôi đã ở đó trước đây,

56
00:03:10.310 --> 00:03:12.270
cho cách bạn tính toán

57
00:03:12.270 --> 00:03:15.465
dz ^ l như một hàm của
dz ^ l trước đó.

58
00:03:15.465 --> 00:03:18.140
Trên thực tế, nếu tôi
chỉ cắm nó vào đây,

59
00:03:18.140 --> 00:03:21.410
bạn kết thúc rằng dz ^ l bằng

60
00:03:21.410 --> 00:03:27.070
thành w ^ l cộng với 1 chuyển vị dz ^ l

61
00:03:27.070 --> 00:03:33.050
cộng 1 lần g ^ l nguyên tố z

62
00:03:33.050 --> 00:03:36.170
của l. Tôi biết điều này có vẻ
như rất nhiều đại số.

63
00:03:36.170 --> 00:03:37.730
Bạn thực sự có thể
kiểm tra kỹ

64
00:03:37.730 --> 00:03:39.290
bản thân rằng
này là phương trình

65
00:03:39.290 --> 00:03:42.575
chúng tôi đã viết ra
lần tuyên truyền ngược vào tuần trước,

66
00:03:42.575 --> 00:03:44.180
khi chúng tôi làm
một mạng nơ-ron

67
00:03:44.180 --> 00:03:45.815
chỉ với một lớp ẩn duy nhất.

68
00:03:45.815 --> 00:03:49.250
Xin nhắc lại, lần này
là sản phẩm khôn ngoan,

69
00:03:49.250 --> 00:03:50.615
vì vậy tất cả những gì bạn cần là

70
00:03:50.615 --> 00:03:54.735
bốn phương trình đó để thực hiện
hàm lùi của bạn.

71
00:03:54.735 --> 00:03:58.510
Và cuối cùng, tôi sẽ viết ra một
phiên bản véc tơ hóa.

72
00:03:58.510 --> 00:04:01.390
Vì vậy, dòng đầu tiên trở thành dz ^ l

73
00:04:01.390 --> 00:04:11.250
bằng da ^ l tích
nguyên tố với g ^ l nguyên tố của z ^ l,

74
00:04:11.250 --> 00:04:13.260
Cũng không có gì bất ngờ ở đó.

75
00:04:13.260 --> 00:04:17.595
Dw ^ l trở thành 1 trên m,

76
00:04:17.595 --> 00:04:22.905
dz ^ l lần a ^ l
trừ 1 chuyển vị.

77
00:04:22.905 --> 00:04:32.630
Khi đó db ^ l trở thành 1
trên m np.sum dz ^ l.

78
00:04:32.630 --> 00:04:37.975
Khi đó trục bằng 1,
keepdims bằng true.

79
00:04:37.975 --> 00:04:39.760
Chúng tôi đã nói về việc sử dụng

80
00:04:39.760 --> 00:04:44.185
np.sum trong
tuần trước, để tính db.

81
00:04:44.185 --> 00:04:51.475
Cuối cùng, da ^ l trừ
1 là w ^ l lần hoán vị

82
00:04:51.475 --> 00:04:57.000
dz của l. Cái này

83
00:04:57.000 --> 00:05:02.590
cho phép bạn nhập
này, da, ở đây.

84
00:05:02.590 --> 00:05:10.065
Xuất ra dW ^ l, dp ^ l,
dẫn xuất bạn cần,

85
00:05:10.065 --> 00:05:15.995
cũng như da ^ l
trừ 1 như sau.

86
00:05:15.995 --> 00:05:18.815
và dA [l-1], đúng chứ? Như ở đây.

87
00:05:18.815 --> 00:05:22.865
Chỉ để tóm tắt,
lấy đầu vào x,

88
00:05:22.865 --> 00:05:25.495
bạn có thể có
lớp đầu tiên có thể

89
00:05:25.495 --> 00:05:28.265
có chức năng kích hoạt ReLU.

90
00:05:28.265 --> 00:05:30.680
Rồi đến lớp thứ hai,

91
00:05:30.680 --> 00:05:33.290
có thể sử dụng một hàm
kích hoạt ReLU khác,

92
00:05:33.290 --> 00:05:36.090
đi đến
thứ ba có thể có

93
00:05:36.090 --> 00:05:37.715
một chức năng kích hoạt sigmoid

94
00:05:37.715 --> 00:05:39.545
Nếu bạn đang thực hiện phân loại nhị phân,

95
00:05:39.545 --> 00:05:41.930
và điều này tạo ra y-hat.

96
00:05:41.930 --> 00:05:46.130
Sau đó, sử dụng y-hat, bạn
có thể tính toán sự mất mát.

97
00:05:46.130 --> 00:05:49.940
và điều này cho phép bạn bắt đầu lặp ngược.

98
00:05:49.940 --> 00:05:51.770
Tôi sẽ vẽ các mũi tên trước.

99
00:05:51.770 --> 00:05:54.125
Tôi đoán tôi không cần phải
bút thay đổi quá nhiều.

100
00:05:54.125 --> 00:05:56.550
Sau đó bạn sẽ ở đâu

101
00:05:57.280 --> 00:06:03.025
có backprop tính toán
các dẫn xuất,

102
00:06:03.025 --> 00:06:07.020
tính toán dW ^ 3,

103
00:06:07.300 --> 00:06:16.385
db ^ 3, dW ^ 2, db ^ 2, dW ^ 1, db ^ 1.

104
00:06:16.385 --> 00:06:19.850
Trên đường đi bạn sẽ là
tính toán so với tiền mặt.

105
00:06:19.850 --> 00:06:25.580
Chúng ta sẽ chuyển z ^ 1, z ^ 2, z ^ 3.

106
00:06:25.580 --> 00:06:32.070
Ở đây bạn chuyển ngược
da ^ 2 và da ^ 1.

107
00:06:32.200 --> 00:06:34.925
Điều này có thể tính da [0],

108
00:06:34.925 --> 00:06:37.790
nhưng chúng tôi sẽ không sử dụng mà để
, bạn có thể chỉ loại bỏ đó.

109
00:06:37.790 --> 00:06:40.790
Đây là cách bạn triển khai
tiến lùi và hỗ trợ lùi cho

110
00:06:40.790 --> 00:06:43.930
một mạng nơ-ron nhân tạo ba lớp.

111
00:06:43.930 --> 00:06:46.430
cuối cùng này mà tôi chưa nói

112
00:06:46.430 --> 00:06:48.744
về cái đó là cho phép đệ quy chuyển tiếp

113
00:06:48.744 --> 00:06:52.415
chúng ta sẽ khởi tạo nó với dữ liệu đầu vào X.

114
00:06:52.415 --> 00:06:54.110
Thế còn về đệ quy ngược?

115
00:06:54.110 --> 00:06:55.945
Nó chỉ ra rằng

116
00:06:55.945 --> 00:07:01.100
da của l khi bạn đang sử dụng
hồi quy logistic,

117
00:07:01.100 --> 00:07:02.810
Nếu bạn đang thực hiện phân loại nhị phân,

118
00:07:02.810 --> 00:07:04.805
bằng với y hơn

119
00:07:04.805 --> 00:07:09.905
a cộng 1 trừ y hơn 1 trừ a.

120
00:07:09.905 --> 00:07:11.690
Nó chỉ ra rằng đạo hàm

121
00:07:11.690 --> 00:07:13.220
của hàm mất mát liên quan đến

122
00:07:13.220 --> 00:07:14.720
đầu ra liên quan đến

123
00:07:14.720 --> 00:07:17.570
y-hat có thể được hiển thị là
.

124
00:07:17.570 --> 00:07:19.100
nếu bạn quen với giải tích,

125
00:07:19.100 --> 00:07:21.500
nếu bạn tra cứu hàm mất mát

126
00:07:21.500 --> 00:07:24.220
lấy các đạo hàm đối với
đối với y-hat đối với a,

127
00:07:24.220 --> 00:07:26.425
bạn có thể chứng minh rằng
bạn có được công thức đó.

128
00:07:26.425 --> 00:07:29.235
Đây là công thức
bạn nên sử dụng cho da,

129
00:07:29.235 --> 00:07:30.440
cho lớp cuối cùng,

130
00:07:30.440 --> 00:07:33.030
vốn L. Tất nhiên nếu bạn

131
00:07:33.030 --> 00:07:35.725
phải có một triển khai

132
00:07:35.725 --> 00:07:36.890
sau đó bạn khởi tạo

133
00:07:36.890 --> 00:07:39.115
đệ quy ngược,
không phải với điều này,

134
00:07:39.115 --> 00:07:42.500
nhưng với da hoa A cho

135
00:07:42.500 --> 00:07:44.915
lớp L sẽ là

136
00:07:44.915 --> 00:07:48.515
điều tương tự đối với
ví dụ khác nhau.

137
00:07:48.515 --> 00:07:53.330
Trên một cho chuyến tàu đầu tiên
ví dụ cộng với 1 trừ

138
00:07:53.330 --> 00:07:55.670
y cho ví dụ về

139
00:07:55.670 --> 00:07:58.475
1 trừ A cho
ví dụ về chuyến tàu đầu tiên,

140
00:07:58.475 --> 00:08:02.975
dot-dot-dot xuống
ví dụ về chuyến tàu thứ n.

141
00:08:02.975 --> 00:08:06.170
Vì vậy, 1 trừ đi một của M. Đó là cách

142
00:08:06.170 --> 00:08:09.485
bạn sẽ triển khai
vectơ hóa.

143
00:08:09.485 --> 00:08:10.939
Đó là cách bạn khởi tạo

144
00:08:10.939 --> 00:08:13.110
phiên bản vectơ hóa
của lan truyền ngược.

145
00:08:13.110 --> 00:08:15.800
Bây giờ chúng ta đã thấy
khối xây dựng cơ bản của

146
00:08:15.800 --> 00:08:19.565
cả truyền xuôi cũng như truyền ngược.

147
00:08:19.565 --> 00:08:22.340
Nếu bạn thực hiện các phương trình này,

148
00:08:22.340 --> 00:08:24.590
bạn sẽ có một triển khai

149
00:08:24.590 --> 00:08:25.910
chuyển tiếp prop và backprop tới

150
00:08:25.910 --> 00:08:27.440
giúp bạn có được
cụ phái sinh mà bạn cần.

151
00:08:27.440 --> 00:08:29.660
Bạn có thể nghĩ,
đó là rất nhiều phương trình.

152
00:08:29.660 --> 00:08:31.340
Tôi hơi bối rối.
Tôi không chắc là tôi thấy

153
00:08:31.340 --> 00:08:33.385
cách này hoạt động như thế nào và nếu
bạn đang cảm thấy như vậy,

154
00:08:33.385 --> 00:08:35.095
lời khuyên của tôi là khi bạn

155
00:08:35.095 --> 00:08:37.225
bài tập lập trình của tuần này,

156
00:08:37.225 --> 00:08:39.650
bạn sẽ có thể
triển khai những điều này cho

157
00:08:39.650 --> 00:08:42.079
bản thân bạn và chúng sẽ bằng
cụ thể hơn nhiều.

158
00:08:42.079 --> 00:08:43.820
Tôi biết những là một
rất nhiều phương trình,

159
00:08:43.820 --> 00:08:45.090
và có thể một số phương trình

160
00:08:45.090 --> 00:08:46.310
không có ý nghĩa hoàn toàn,

161
00:08:46.310 --> 00:08:48.330
nhưng nếu bạn làm việc thông qua

162
00:08:48.330 --> 00:08:50.940
phép tính toán và
không hề đơn giản,

163
00:08:50.940 --> 00:08:52.410
và hãy cứ thoải mái thử,

164
00:08:52.410 --> 00:08:53.770
nhưng đó thực sự là
một trong những

165
00:08:53.770 --> 00:08:56.200
các dẫn xuất khó
trong học máy.

166
00:08:56.200 --> 00:08:58.040
Hóa ra các phương trình
mà chúng tôi đã viết ra là

167
00:08:58.040 --> 00:08:59.690
chỉ là các phương trình giải tích

168
00:08:59.690 --> 00:09:01.160
đạo hàm tự nhiên nhất.

169
00:09:01.160 --> 00:09:03.510
đặc biệt là trong backprop,
nhưng một lần nữa,

170
00:09:03.510 --> 00:09:04.830
nếu điều này cảm thấy một
chút trừu tượng chút,

171
00:09:04.830 --> 00:09:06.215
hoặc khó hiểu

172
00:09:06.215 --> 00:09:09.115
lời khuyên của tôi là khi bạn đã hoàn thành
bài tập lập trình,

173
00:09:09.115 --> 00:09:11.495
thì bạn sẽ thấy nó cụ thể hơn một chút.

174
00:09:11.495 --> 00:09:13.670
Mặc dù tôi phải nói, ngay cả

175
00:09:13.670 --> 00:09:15.910
hôm nay khi tôi triển khai
một thuật toán học tập,

176
00:09:15.910 --> 00:09:17.970
đôi khi thậm chí tôi
ngạc nhiên khi

177
00:09:17.970 --> 00:09:19.474
triển khai thuật toán học tập

178
00:09:19.474 --> 00:09:20.430
hoạt động và đó là bởi vì

179
00:09:20.430 --> 00:09:22.130
rất nhiều sự phức tạp của

180
00:09:22.130 --> 00:09:23.520
máy học đến từ

181
00:09:23.520 --> 00:09:25.700
dữ liệu thay vì
từ các dòng mã.

182
00:09:25.700 --> 00:09:27.095
Đôi khi bạn cảm thấy như

183
00:09:27.095 --> 00:09:28.710
bạn thực hiện một vài dòng mã,

184
00:09:28.710 --> 00:09:30.120
và không chắc chắn về những
gì nó đã thực hiện,

185
00:09:30.120 --> 00:09:31.550
nhưng nó lại hoạt động một cách kỳ diệu,

186
00:09:31.550 --> 00:09:33.800
và đó là bởi vì rất nhiều
thực sự không có trong

187
00:09:33.800 --> 00:09:37.090
đoạn mã bạn viết
thường không quá dài.

188
00:09:37.090 --> 00:09:38.730
Nó không hằn là đơn giản,

189
00:09:38.730 --> 00:09:40.770
nhưng nó không phải là 10.000,

190
00:09:40.770 --> 00:09:42.125
100.000 dòng mã,

191
00:09:42.125 --> 00:09:44.070
nhưng bạn cung cấp cho nó
quá nhiều dữ liệu

192
00:09:44.070 --> 00:09:45.420
đôi khi mặc dù tôi

193
00:09:45.420 --> 00:09:46.835
đã làm việc với máy
trong một thời gian dài,

194
00:09:46.835 --> 00:09:48.865
đôi khi nó vẫn gây ngạc nhiên

195
00:09:48.865 --> 00:09:50.540
cho tôi một chút khi
học của tôi hoạt động,

196
00:09:50.540 --> 00:09:52.430
bởi vì rất nhiều
độ phức tạp của

197
00:09:52.430 --> 00:09:55.065
thuật toán học tập
của bạn đến từ dữ liệu

198
00:09:55.065 --> 00:09:57.440
thay vì nhất thiết phải từ bạn

199
00:09:57.440 --> 00:10:01.150
viết hàng nghìn và
nghìn dòng mã.

200
00:10:01.580 --> 00:10:05.930
Đó là cách bạn triển khai
mạng nơron sâu.

201
00:10:05.930 --> 00:10:07.260
Một lần nữa, điều này sẽ trở nên nhiều hơn

202
00:10:07.260 --> 00:10:09.925
cụ thể khi bạn đã hoàn thành
bài tập lập trình.

203
00:10:09.925 --> 00:10:14.210
Trước khi tiếp tục bài học, thì
trong video tiếp theo,

204
00:10:14.210 --> 00:10:17.465
tôi sẽ nói về các tham số và siêu tham số.

205
00:10:17.465 --> 00:10:19.720
Trên thực tế khi bạn huấn luyện mạng sâu,

206
00:10:19.720 --> 00:10:22.225
việc có thể tổ chức tốt các siêu tham số

207
00:10:22.225 --> 00:10:23.920
sẽ giúp bạn hiệu quả hơn

208
00:10:23.920 --> 00:10:25.400
trong việc phát triển mạng của bạn.

209
00:10:25.400 --> 00:10:26.780
Trong video tiếp theo, chúng ta hãy bàn

210
00:10:26.780 --> 00:10:29.130
xem điều đó chính xác là gì.