WEBVTT

1
00:00:00.450 --> 00:00:04.786
Python cho phép bạn sử dụng các
 phép toán truyền phát và khái quát hơn

2
00:00:04.786 --> 00:00:09.944
thì tôi nghĩ tính linh hoạt tuyệt vời của
 ngôn ngữ lập trình numpy python chính là,

3
00:00:09.944 --> 00:00:14.748
Tôi nghĩ, đó là điểm mạnh cũng như
 điểm yếu của ngôn ngữ lập trình này.

4
00:00:14.748 --> 00:00:18.393
Tôi nghĩ đó là một điểm mạnh bởi vì
 chúng tạo ra tính biểu cảm của ngôn ngữ.

5
00:00:18.393 --> 00:00:22.547
Sự linh hoạt tuyệt vời của ngôn ngữ 
giúp bạn hoàn thành rất nhiều việc chỉ với

6
00:00:22.547 --> 00:00:24.165
một dòng mã duy nhất.

7
00:00:24.165 --> 00:00:28.530
Nhưng đó cũng là điểm yếu bởi vì
 với truyền phát và số lượng lớn

8
00:00:28.530 --> 00:00:32.610
tính linh hoạt này, thì đôi khi có thể 
bạn sẽ đưa vào các lỗi rất tinh vi hoặc

9
00:00:32.610 --> 00:00:36.530
lỗi trông rất kỳ lạ, nếu bạn không quen 
với tất cả những yếu tố phức tạp trong

10
00:00:36.530 --> 00:00:39.800
cách truyền phát và cách hoạt động 
của các tính năng như truyền phát.

11
00:00:39.800 --> 00:00:44.500
Ví dụ: nếu bạn lấy một vectơ cột và
 cộng nó với một vectơ hàng, bạn sẽ

12
00:00:44.500 --> 00:00:48.700
mong nó đưa ra một lỗi không tương quan về
 chiều hoặc lỗi đánh máy hoặc một cái gì đó.

13
00:00:48.700 --> 00:00:52.620
Nhưng bạn lại có thể có kết quả là một 
ma trận dưới dạng tổng của một vectơ hàng và

14
00:00:52.620 --> 00:00:54.030
một vectơ cột.

15
00:00:54.030 --> 00:00:58.370
Vì vậy, có một logic bên trong đối
 với các hiệu ứng lạ này của Python.

16
00:00:58.370 --> 00:01:03.370
Nhưng nếu bạn không quen sử dụng Python,
 tôi đã thấy một số sinh viên thấy rất lạ lẫm,

17
00:01:03.370 --> 00:01:05.680
rất khó tìm lỗi.

18
00:01:05.680 --> 00:01:09.380
Vì vậy, trong video tôi muốn 
chia sẻ với bạn một số mẹo và

19
00:01:09.380 --> 00:01:12.800
thủ thuật hữu ích để loại bỏ hoặc

20
00:01:12.800 --> 00:01:17.320
đơn giản hóa và loại bỏ tất cả các
 lỗi kỳ lạ trong mã của riêng tôi.

21
00:01:17.320 --> 00:01:19.280
Và tôi hy vọng rằng với 
những mẹo và thủ thuật này,

22
00:01:19.280 --> 00:01:24.193
bạn cũng sẽ có thể viết mã python và
 numpy không bị lỗi dễ dàng hơn nhiều.

23
00:01:25.430 --> 00:01:30.200
Để minh họa một trong những hiệu ứng
 không trực quan lắm của Python-Numpy,

24
00:01:30.200 --> 00:01:34.990
đặc biệt là cách bạn xây dựng các vectơ trong
 Python-Numpy, tôi sẽ thực hiện một bản demo nhanh.

25
00:01:34.990 --> 00:01:40.817
Đặt a = np.random.randn (5),

26
00:01:40.817 --> 00:01:45.699
và điều này tạo ra năm 
biến Gaussian ngẫu nhiên

27
00:01:45.699 --> 00:01:49.640
được lưu trữ trong mảng a.

28
00:01:49.640 --> 00:01:55.420
Và print(a) và bây giờ hóa ra

29
00:01:55.420 --> 00:02:02.740
hình dạng của a khi bạn làm điều
 này là cấu trúc năm màu này.

30
00:02:02.740 --> 00:02:06.320
Và do đó, đây được gọi là 
mảng hạng 1 trong Python và

31
00:02:06.320 --> 00:02:09.750
nó không phải là một 
vectơ hàng hay một vectơ cột.

32
00:02:09.750 --> 00:02:12.570
Và điều này dẫn đến nó có 
một số hiệu ứng không trực quan.

33
00:02:12.570 --> 00:02:17.180
Ví dụ nếu tôi in a chuyển vị, 
thì nó sẽ có kết quả như a.

34
00:02:17.180 --> 00:02:20.220
Vì vậy, a và a chuyển vị 
có kết quả như nhau.

35
00:02:20.220 --> 00:02:25.800
Và nếu tôi in tích trong giữa a 
và a chuyển vị, bạn có thể nghĩ

36
00:02:25.800 --> 00:02:30.190
một nhân a chuyển vị có thể là kết quả
 bên ngoài mà sẽ đưa cho bạn ma trận.

37
00:02:30.190 --> 00:02:34.170
Nhưng nếu tôi làm điều đó, thì 
thay vào đó bạn lại có được một số.

38
00:02:34.170 --> 00:02:39.612
Vì vậy, điều tôi muốn giới thiệu là
 khi bạn mã hóa các mạng mới,

39
00:02:39.612 --> 00:02:46.115
bạn sẽ không sử dụng các cấu trúc dữ liệu
 mà có hình dạng là 5 hoặc n, mảng hạng 1.

40
00:02:46.115 --> 00:02:52.134
Mà thay vào đó, nếu bạn
 đặt a bằng cái này, (5,1),

41
00:02:52.134 --> 00:02:58.764
thì nó sẽ cam kết
 a là vectơ cột (5,1).

42
00:02:58.764 --> 00:03:02.399
Và trong khi trước đây, a và 
a chuyển vị trông giống nhau, thì

43
00:03:02.399 --> 00:03:06.590
bây giờ nó trở thành a chuyển vị,
 bây giờ a chuyển vị là một vector hàng.

44
00:03:06.590 --> 00:03:08.437
Hãy lưu ý điểm khác biệt nhỏ sau.

45
00:03:08.437 --> 00:03:12.213
Trong cấu trúc dữ liệu này, có hai dấu
 ngoặc vuông khi chúng ta in a chuyển vị.

46
00:03:12.213 --> 00:03:14.460
Trong khi trước đây, có 
một dấu ngoặc vuông.

47
00:03:14.460 --> 00:03:19.393
Vì vậy, đây là điểm 
khác biệt là một ma trận

48
00:03:19.393 --> 00:03:23.481
(1,5) với một trong 
các mảng hạng 1 này.

49
00:03:23.481 --> 00:03:28.129
Và nếu bạn in, giả sử, 
tích giữa a và a chuyển vị,

50
00:03:28.129 --> 00:03:32.444
thì điều này sẽ đưa cho bạn 
tích ngoài của một vector, đúng chứ?

51
00:03:32.444 --> 00:03:35.795
Và do đó, tích ngoài của một vectơ
 cung cấp cho bạn một ma trận.

52
00:03:35.795 --> 00:03:40.305
Và hãy xem xét kỹ hơn về 
những gì chúng ta vừa thấy ở đây.

53
00:03:40.305 --> 00:03:43.185
Lệnh đầu tiên mà 
chúng ta chạy, là đây.

54
00:03:43.185 --> 00:03:47.839
Và điều này tạo ra 
một cấu trúc dữ liệu với

55
00:03:47.839 --> 00:03:52.930
a.shape, bằng (5,) và

56
00:03:52.930 --> 00:03:57.270
đây được gọi là mảng hạng 1.

57
00:03:57.270 --> 00:03:58.960
Và đây là một cấu trúc 
dữ liệu rất hài hước.

58
00:03:58.960 --> 00:04:04.000
Nó không hoạt động nhất quán 
như là một vectơ hàng hay vectơ cột,

59
00:04:04.000 --> 00:04:06.750
và điều này làm cho một số 
hiệu ứng của nó không trực quan.

60
00:04:06.750 --> 00:04:10.770
Vì vậy, tôi muốn nói là 
khi bạn làm bài tập

61
00:04:10.770 --> 00:04:14.050
lập trình, hoặc trong thực tế khi bạn
 đang triển khai hồi quy logistic hoặc

62
00:04:14.050 --> 00:04:19.740
mạng nơ-ron nhân tạo thì bạn
 đừng sử dụng các mảng hạng 1 này.

63
00:04:21.020 --> 00:04:24.098
Thay vào đó, mỗi lần bạn tạo một mảng,

64
00:04:24.098 --> 00:04:27.500
thì hãy cam kết biến nó
 thành một vectơ cột, như vậy

65
00:04:27.500 --> 00:04:32.360
điều này tạo ra một vectơ (5,1) hoặc
 cam kết biến nó thành một vectơ hàng,

66
00:04:32.360 --> 00:04:36.670
và rồi cách hoạt động của các
 vectơ của bạn sẽ dễ hiểu hơn.

67
00:04:36.670 --> 00:04:43.115
Vì vậy, trong trường hợp này,
 a.shape sẽ bằng 5,1.

68
00:04:43.115 --> 00:04:48.510
Và do đó, nó chạy rất giống a, nhưng
 trên thực tế, đây là một vectơ cột.

69
00:04:48.510 --> 00:04:53.233
Và đó là lý do tại sao bạn có thể nghĩ đây là
 ma trận (5,1), trong đó nó là một vectơ cột.

70
00:04:53.233 --> 00:04:56.880
Và ở đây a.shape sẽ là (1,5),

71
00:04:56.880 --> 00:05:01.000
và điều này chạy 
như một vector hàng.

72
00:05:02.150 --> 00:05:06.258
Vì vậy, khi bạn cần một vectơ, tôi sẽ nói rằng
 hãy sử dụng cái này hoặc cái này, nhưng

73
00:05:06.258 --> 00:05:07.538
đừng dùng một mảng hạng 1.

74
00:05:07.538 --> 00:05:12.061
Một điều nữa mà tôi thực hiện rất nhiều trong mã 
của mình là nếu tôi không hoàn toàn chắc chắn về

75
00:05:12.061 --> 00:05:17.029
kích thước của một trong các vectơ của tôi, 
thì tôi sẽ thường đưa ra một câu lệnh xác định

76
00:05:17.029 --> 00:05:21.720
như thế này, để chắc chắn, trong
 trường hợp này, đây là một vectơ (5,1).

77
00:05:21.720 --> 00:05:23.730
Và đây là một vector cột.

78
00:05:23.730 --> 00:05:26.900
Những xác định này thì rất 
dễ để được thực thi và

79
00:05:26.900 --> 00:05:30.250
chúng cũng sẽ trở thành 
tài liệu cho mã của bạn.

80
00:05:30.250 --> 00:05:34.160
Vì vậy, đừng ngần ngại đưa ra những câu lệnh
 xác định như thế này bất cứ khi nào bạn

81
00:05:34.160 --> 00:05:35.320
cảm thấy cần phải sử dụng.

82
00:05:35.320 --> 00:05:39.510
Và cuối cùng, nếu vì một lý do nào đó, 
bạn có kết quả là một mảng hạng 1,

83
00:05:39.510 --> 00:05:43.960
thì bạn có thể định hình lại
 cái này, a bằng a.reshape

84
00:05:43.960 --> 00:05:48.900
một mảng (5,1) hoặc 
một mảng (1,5) và

85
00:05:48.900 --> 00:05:53.750
nó sẽ chạy nhất quán hơn 
như là vectơ cột hoặc vectơ hàng.

86
00:05:53.750 --> 00:05:57.626
Vì vậy, đôi khi tôi thấy các sinh
 viên đã gặp khó khăn khi theo dõi

87
00:05:57.626 --> 00:06:01.119
bởi vì đó là những ảnh hưởng 
không trực quan của mảng hạng 1.

88
00:06:01.119 --> 00:06:06.246
Bằng cách loại bỏ mảng hạng 1 trong mã cũ, 
 tôi nghĩ mã của tôi đã trở nên đơn giản hơn.

89
00:06:06.246 --> 00:06:09.463
Và tôi không thấy hạn chế gì 
về những điều mà tôi có thể

90
00:06:09.463 --> 00:06:10.335
thể hiện trong mã.

91
00:06:10.335 --> 00:06:12.469
Tôi chỉ không bao giờ 
sử dụng một mảng hạng 1.

92
00:06:12.469 --> 00:06:17.090
Và vì vậy, điều rút ra là để đơn giản hóa mã
 của bạn, không sử dụng mảng hạng 1.

93
00:06:17.090 --> 00:06:19.437
Luôn luôn sử dụng ma trận (n,1),

94
00:06:19.437 --> 00:06:24.510
cơ bản là các vectơ cột, hoặc 
ma trận (1,n), là các vectơ hàng.

95
00:06:24.510 --> 00:06:26.599
Hãy thoải mái thực hiện 
nhiều câu lệnh xác định, và

96
00:06:26.599 --> 00:06:29.590
kiểm tra kỹ các kích thước 
của ma trận và mảng của bạn.

97
00:06:29.590 --> 00:06:34.480
Ngoài ra, đừng ngại gọi phép toán 
định hình lại để đảm bảo rằng

98
00:06:34.480 --> 00:06:38.780
ma trận hoặc vectơ của bạn 
có chiều mà bạn cần.

99
00:06:38.780 --> 00:06:39.420
Vì thế,

100
00:06:39.420 --> 00:06:44.770
tôi hy vọng rằng bộ đề xuất này sẽ giúp
 bạn loại trừ được nguyên nhân gây ra lỗi

101
00:06:44.770 --> 00:06:48.840
từ mã Python và giúp bạn
 hoàn thành bài tập dễ dàng hơn.